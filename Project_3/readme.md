# 프로젝트 3: 가상 메모리

## 과제 요구사항

*   xv6에 세 가지 시스템 콜과 페이지 폴트 핸들러 구현
    *   mmap() 시스템 콜
    *   페이지 폴트 핸들러
    *   munmap() 시스템 콜
    *   freemem() 시스템 콜

### mmap() 시스템 콜

*   mmap() 개요

    ```
    uint mmap(uint addr, int length, int prot, int flags, int fd, int offset)
    ```

    1.  addr은 항상 페이지 정렬됨
    2.  각 프로세스의 가상 주소인 MMAPBASE는 0x40000000
        *   MMAPBASE + addr은 매핑의 시작 주소
        *   length 또한 페이지 크기의 배수
        *   MMAPBASE + addr + length는 매핑의 끝 주소
    3.  prot는 PROT_READ 또는 PROT_READ|PROT_WRITE가 될 수 있음
        *   prot는 파일의 열린 플래그와 일치해야 함
    4.  flags는 다음 조합으로 제공될 수 있음
        1.  MAP_ANONYMOUS가 주어지면 익명 매핑임
        2.  MAP_ANONYMOUS가 주어지지 않으면 파일 매핑임
        3.  MAP_POPULATE가 주어지면 물리적 페이지를 할당하고 전체 매핑 영역에 대한 페이지 테이블을 만듦
        4.  MAP_POPULATE가 주어지지 않으면 해당 매핑 영역만 기록
            *   매핑 영역의 가상 주소에 대한 액세스인 해당 영역에 페이지 폴트가 발생하면 물리적 페이지를 할당하고 해당 페이지에 페이지 테이블을 만듦
        5.  다른 플래그는 사용되지 않음
    5.  fd는 파일 매핑에 제공되며, 그렇지 않으면 -1이어야 함
    6.  offset은 파일 매핑에 제공되며, 그렇지 않으면 0이어야 함
*   반환
    *   성공: 매핑 영역의 시작 주소 반환
    *   실패: 0 반환
        *   익명이 아니지만 fd가 -1인 경우
        *   파일의 보호와 매개변수의 prot가 다른 경우
        *   매핑 영역이 겹치는 상황은 고려하지 않음
        *   추가 오류가 발생하면 알림을 작성하여 알려줌

### 페이지 폴트 핸들러

*   페이지 폴트 핸들러는 물리적 페이지 및 페이지 테이블이 할당되지 않은 매핑 영역에 대한 액세스를 처리하기 위한 것임
*   성공: 물리적 페이지와 페이지 테이블 항목이 정상적으로 생성되고 프로세스가 문제 없이 작동됨
*   실패: 프로세스가 종료됨
    1.  액세스(읽기/쓰기)가 발생하면 traps.h에서 해당 페이지 폴트(인터럽트 14, T_PGFLT)를 캐치함
    2.  페이지 폴트 핸들러에서 rcr2()를 사용하여 CR2 레지스터를 읽고 액세스가 읽기 또는 쓰기였는지 확인하여 폴트 주소를 확인함
        *   읽기: tf->err&2 == 0 / 쓰기: tf->err&2 == 1
    3.  mmap_area에서 해당 매핑 영역을 찾음
        *   폴트가 발생한 주소에 해당하는 mmap_area가 없으면 -1을 반환
    4.  mmap_area가 쓰기 금지인 동안 폴트가 쓰기인 경우 -1을 반환
    5.  폴트가 발생한 주소에 따라 하나의 페이지에 대해서만 다음을 수행함
        1.  새 물리적 페이지를 할당
        2.  새 페이지를 0으로 채움
        3.  파일 매핑인 경우 오프셋으로 물리적 페이지에 파일을 읽음
        4.  익명 매핑인 경우 0으로 채워진 페이지를 그대로 둠
        5.  페이지 테이블을 만들고 적절하게 채움(PROT_WRITE인 경우 PTE 값에서 PTE_W는 1이어야 함)

### munmap() 시스템 콜

*   munmap(addr)
*   해당 매핑 영역을 언매핑함
*   반환 값: 1(성공), -1(실패)
    1.  addr은 항상 페이지 정렬된 매핑 영역의 시작 주소와 함께 제공됨
    2.  munmap()은 해당 mmap_area 구조체를 제거해야 함
        *   주소로 시작하는 프로세스의 mmap_area가 없으면 -1을 반환
    3.  물리적 페이지가 할당되고 페이지 테이블이 구성되면 물리적 페이지 및 페이지 테이블을 해제해야 함
        *   물리적 페이지를 해제할 때 1로 채우고 프리리스트에 다시 넣어야 함
    4.  물리적 페이지가 할당되지 않은 경우(해당 주소에서 페이지 폴트가 발생하지 않은 경우) mmap_area 구조체만 제거함
    5.  주의) 하나의 mmap_area에서 일부 페이지는 할당되고 일부는 할당되지 않은 상황이 발생할 수 있음

### freemem() 시스템 콜

*   현재 사용 가능한 메모리 페이지 수를 반환하는 시스템 콜
    1.  커널이 해제(페이지를 프리리스트에 넣음)하면 freemem이 증가해야 함
    2.  커널이 할당(프리리스트에서 페이지를 가져와 프로세스에 제공)하면 freemem이 감소해야 함
