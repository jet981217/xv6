# 프로젝트 4: 페이지 교체

## 과제 요구사항

*   xv6에 페이지 레벨 스와핑 구현
    *   스왑 인: 희생 페이지를 백업 저장소에서 메인 메모리로 이동
    *   스왑 아웃: 희생 페이지를 메인 메모리에서 백업 저장소로 이동
*   LRU 목록으로 스왑 가능한 페이지 관리
    *   페이지 교체 정책: 클락 알고리즘
*   xv6에서 생성하거나 수정해야 하는 코드
    *   스왑 인, 스왑 아웃 연산
    *   LRU 목록 관리
*   몇 가지 추가 사항

## 스와핑이란?

*   물리적 메모리가 충분하지 않을 때 프로세스 지원
    *   메모리에서 백업 저장소로 임시 스왑 가능
*   메모리에서 백업 저장소로 페이지 스왑 아웃
*   백업 저장소에서 메모리로 페이지 스왑 인

## xv6의 스왑 가능 페이지 (1)

*   사용자 페이지 만 스왑 가능
    *   일부 물리적 페이지는 스왑 아웃해서는 안 됨
        *   예: 페이지 테이블 페이지
*   따라서 LRU 목록 (원형 이중 연결 목록)으로 스왑 가능 페이지 관리
    *   init/alloc/dealloc/copy 사용자 가상 메모리 시

## xv6의 스왑 가능 페이지 (2)

*   페이지 교체 알고리즘: 클락 알고리즘
    *   각 PTE에서 A (Accessed) 비트 사용 (PTE_A: 0x20)
    *   lru_head에서 다음 포인터를 따라 희생 페이지 선택
        *   PTE_A==1이면 지우고 페이지를 LRU 목록의 테일로 보냄
        *   PTE_A==0이면 페이지 제거 (희생 페이지)
    *   QEMU는 액세스 시 PTE A 비트를 자동으로 설정
    *   kalloc() 함수를 통해 여유 페이지를 얻지 못한 경우
        *   희생 페이지를 스왑 아웃

## xv6의 스왑 아웃 연산

1.  swapwrite() 함수를 사용하여 희생 페이지를 스왑 공간에 씀
    *   swapwrite()는 스켈레톤 코드에서 제공
2.  희생 페이지의 PTE는 스왑 공간 오프셋으로 설정됨
3.  PTE P는 지워짐

## xv6의 스왑 인 연산

*   스왑 아웃된 페이지에 액세스 할 때
    1.  새 물리적 페이지 가져오기
    2.  swapread() 함수를 사용하여 스왑 공간에서 물리적 페이지로 읽음
        *   swapread()는 스켈레톤 코드에서 제공
    3.  물리적 주소로 PTE 값 변경 및 PTE_P 설정
        *   팁: 페이지 테이블은 이미 할당되었으므로 mappages()를 호출 할 필요가 없음

## 몇 가지 고려 사항 및 가정

*   스왑 공간을 추적하기 위해 1개의 물리적 페이지를 비트 맵에 사용
    *   페이지가 스왑 공간으로 스왑 아웃되면 비트 맵의 비트가 설정됨
    *   페이지가 스왑 공간으로 스왑 인되면 비트 맵의 비트가 지워짐
*   사용자 가상 메모리가 복사 될 때
    *   현재 페이지를 복사해야 함
    *   스왑 아웃된 페이지도 복사해야 함
*   사용자 가상 메모리가 할당 해제 될 때
    *   현재 페이지를 해제하고 PTE 비트를 0으로 설정하고 LRU 목록에서 제거해야 함
    *   스왑 아웃된 페이지는 비트 맵에서 지워야 하고 PTE 비트를 0으로 설정해야 함

## 몇 가지 고려 사항 및 가정

*   스왑 아웃이 발생해야 하고 LRU 목록에 페이지가 없으면
    *   OOM (Out of memory) 오류가 발생해야 함
    *   kalloc 함수 내에서 오류 메시지를 cprintf로 표시
    *   OOM이 발생하면 kalloc은 0을 반환해야 함
*   잠금은 동기화를 위해 공유 리소스와 함께 고려해야 함
*   모든 페이지는 struct page에서 관리됨
    *   스켈레톤 코드에 이미 구현됨 (mmu.h)

## 스켈레톤 코드

*   스켈레톤 코드는 세 가지 기능을 제공
    *   스왑 공간에서 읽기/쓰기 기능 제공
        *   void swapread(char\* ptr, int blkno)
        *   void swapwrite(char\* ptr, int blkno)
    *   스왑 공간 액세스를 측정하는 기능
        *   void swapstat(int\* nr_sectors_read, int\* nr_sectors_write)
    *   커널 부트 블록이 스왑 공간으로 사용되도록 확장됨
        *   Makefile param.h

## 테스트 방법 (1)

*   main.c의 main()
*   xv6가 시작되면 kinit1 및 kinit2 함수가 호출됨
    *   kinit1 호출은 처음 4MB에서 잠금없는 할당을 설정
    *   kinit2 호출은 잠금을 활성화하고 더 많은 메모리를 할당 할 수 있도록 준비

## 테스트 방법 (2)

*   처음에는 여유 페이지가 너무 많으므로 PHYSTOP를 줄여 여유 페이지를 줄여야 함
    1.  다음 중 하나를 선택하여 메모리 소비
        1.  많은 프로세스 생성 (fork())
        2.  사용자 명령 ls
        3.  sbrk() 시스템 콜
    2.  다음 중 하나를 선택하여 스왑 모니터링
        1.  swapstat()
        2.  LRU 목록 길이 및 스왑 인/아웃 작업 모니터링
*   위의 방법을 사용하여 자신의 코드 테스트

## 제출

*   스켈레톤 코드부터 시작 (이전 프로젝트가 아님)
    *   $ cp \~swe3004/pa4\_sklt\_xv6.tar.gz \~/
    *   $ tar -xzf \~/pa4\_sklt\_xv6.tar.gz
*   Ji Server에서 제출 및 제출 확인 바이너리 파일 사용
    *   $ \~swe3004/bin/submit pa4 xv6-public
    *   여러 번 제출할 수 있으며, 제출 내역은 check-submission을 통해 확인할 수 있음
    *   마지막 제출만 채점됨
